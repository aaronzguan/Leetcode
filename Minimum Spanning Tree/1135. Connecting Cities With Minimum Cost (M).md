## 1135. Connecting Cities With Minimum Cost (M)

There are `N` cities numbered from 1 to `N`.

You are given `connections`, where each `connections[i] = [city1, city2, cost]` represents the cost to connect `city1` and `city2` together. (A *connection* is bidirectional: connecting `city1` and `city2` is the same as connecting `city2` and `city1`.)

Return the minimum cost so that for every pair of cities, there exists a path of connections (possibly of length 1) that connects those two cities together. The cost is the sum of the connection costs used. If the task is impossible, return -1.

**Example:**

![img](https://assets.leetcode.com/uploads/2019/04/20/1314_ex2.png)

```
Input: N = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
Output: 6
Explanation: 
Choosing any 2 edges will connect all cities so we choose the minimum 2.
```



### 1. Prim's Algorithm

1. **Start at a random node** and put the node in the **min-heap**
2. Get the top element from the min-heap which has the lowest cost.
3. **Add its neighbor** into the min-heap so that we can visit cities via the lowest cost paths
4. Do step2 and step3 over and over **until the heap is clear**.
5. We'll eventually **hit all cities (if the graph allows) at min cost**.

```python
class Solution(object):
    def minimumCost(self, N, connections):
        """
        :type N: int
        :type connections: List[List[int]]
        :rtype: int
        """
        # create undirected graph
        graph = collections.defaultdict(list)
        for c1, c2, cost in connections:
            graph[c1].append([c2, cost])
            graph[c2].append([c1, cost])
       
        # create the heap with our starting cost and random location
        heap = [(0, 1)]
        heapq.heapify(heap)
        visited = set()
        total_cost = 0
        
        while heap:
            cost, city = heapq.heappop(heap)
            if city not in visited:
                visited.add(city)
                total_cost += cost
                # Add the neighbor and costs into the heap
                for neighbor, next_cost in graph[city]:
                    heapq.heappush(heap,(next_cost, neighbor))
        # Return our cost if we have visited all N nodes
        return total_cost if len(visited) == N else -1
```



### 2. Kruskal Akgorithm

1. Firstly sort the edges such that we can start off by selecting the edge with min cost.
2. The **number of edges would be  N - 1**
3. Check if the two nodes have the same parent, which means they are already connected in a path
4. If not, then changed parent of the second node to be the parent of the first node such that we connect the 2 nodes in this way.

```python
class Solution(object):
    def minimumCost(self, N, connections):
        """
        :type N: int
        :type connections: List[List[int]]
        :rtype: int
        """
        def find_parent(node):
            parent = parents[node]
            # Search to the top parent
            while node != parent:
                node = parent
                parent = parents[node]
            return node
        
        # Sort the edges such that we can start with edge with min cost
        connections.sort(key=lambda x : x[2])
        
        # Paranet array for union find
        #  N + 1 is because the city number is from 1 to N -> parents[i] = i
        parents = [i for i in range(N + 1)] 

        cost = 0
        edge_count = 0 
        
        for city1, city2, cur_cost in connections:
            # if they are not in the same, connecting city2's parent to city1's parent to make them in the same set
            if find_parent(city1) != find_parent(city2):
                # Make their parent same
                parents[find_parent(city2)] = find_parent(city1)
                cost += cur_cost
                edge_count += 1
                
                if edge_count == N - 1:
                    return cost
        
        return -1 if edge_count < N-1 else cost
```

